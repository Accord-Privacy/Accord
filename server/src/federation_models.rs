//! Data models for the Accord federation protocol.
//!
//! Federation enables Accord servers to communicate with each other so users
//! on different servers can interact. E2E encryption is preserved — federated
//! servers are relays, not endpoints.

use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Federated user identifier: `username@server.domain`
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct FederatedUserId {
    pub username: String,
    pub server_domain: String,
}

impl FederatedUserId {
    pub fn new(username: &str, server_domain: &str) -> Self {
        Self {
            username: username.to_string(),
            server_domain: server_domain.to_string(),
        }
    }

    pub fn parse(s: &str) -> Option<Self> {
        let (username, domain) = s.split_once('@')?;
        if username.is_empty() || domain.is_empty() {
            return None;
        }
        Some(Self {
            username: username.to_string(),
            server_domain: domain.to_string(),
        })
    }

    pub fn to_string_repr(&self) -> String {
        format!("{}@{}", self.username, self.server_domain)
    }

    /// Returns true if this user belongs to the given server domain.
    pub fn is_local(&self, local_domain: &str) -> bool {
        self.server_domain == local_domain
    }
}

impl std::fmt::Display for FederatedUserId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}@{}", self.username, self.server_domain)
    }
}

/// Information about a federated server.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerInfo {
    /// The domain of this server (e.g., "accord.example.com")
    pub domain: String,
    /// Ed25519 public key (base64-encoded) for verifying signatures
    pub public_key: String,
    /// Protocol version supported
    pub protocol_version: u32,
    /// Server software version
    pub software_version: String,
    /// Capabilities this server supports
    pub capabilities: Vec<String>,
}

/// The set of capabilities a server can advertise.
pub mod capabilities {
    pub const MESSAGING: &str = "messaging";
    pub const TYPING: &str = "typing";
    pub const PRESENCE: &str = "presence";
    pub const FILE_TRANSFER: &str = "file_transfer";
}

/// Events that can be sent between federated servers.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "event_type", content = "payload")]
pub enum FederationEvent {
    /// A message from a user on the sending server to a user/channel on the receiving server.
    /// The content is E2E encrypted — the federation layer cannot read it.
    Message {
        /// Unique message ID (generated by sender)
        message_id: Uuid,
        /// Federated sender
        from: FederatedUserId,
        /// Federated recipient (user or channel)
        to: FederatedUserId,
        /// E2E encrypted payload (base64). Opaque to both servers.
        encrypted_payload: String,
        /// Optional: reply to a previous message
        reply_to: Option<Uuid>,
    },

    /// Typing indicator.
    TypingStart {
        from: FederatedUserId,
        to: FederatedUserId,
        channel_id: Option<Uuid>,
    },

    /// Presence update.
    PresenceUpdate {
        user: FederatedUserId,
        status: String,
        custom_status: Option<String>,
    },

    /// A user on the sending server wants to join a federated Node on the receiving server.
    JoinRequest {
        user: FederatedUserId,
        node_id: Uuid,
        invite_code: Option<String>,
    },

    /// Response to a join request.
    JoinResponse {
        user: FederatedUserId,
        node_id: Uuid,
        accepted: bool,
        reason: Option<String>,
    },

    /// A user left a federated Node.
    Leave {
        user: FederatedUserId,
        node_id: Uuid,
    },

    /// Server info exchange (handshake).
    ServerHello { info: ServerInfo },
}

/// A signed, authenticated envelope for federation messages.
///
/// Every message between servers is wrapped in this envelope.
/// The signature covers `sender_domain + timestamp + nonce + event_json`.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederatedMessage {
    /// Domain of the sending server
    pub sender_domain: String,
    /// Domain of the intended recipient server
    pub recipient_domain: String,
    /// Unix timestamp (seconds) when this was created
    pub timestamp: u64,
    /// Random nonce to prevent replay attacks (base64)
    pub nonce: String,
    /// The actual event payload (JSON-serialized FederationEvent)
    pub event: FederationEvent,
    /// Ed25519 signature over the canonical form (base64)
    pub signature: String,
}

/// Challenge-response for server verification.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerChallenge {
    /// Random challenge bytes (base64)
    pub challenge: String,
    /// The domain being challenged
    pub challenger_domain: String,
    /// Timestamp
    pub timestamp: u64,
}

/// Response to a server challenge.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerChallengeResponse {
    /// The original challenge (base64)
    pub challenge: String,
    /// Signature of the challenge by the responding server (base64)
    pub signature: String,
    /// The responding server's info
    pub server_info: ServerInfo,
}

/// Well-known federation endpoint discovery response.
/// Served at `/.well-known/accord-federation`.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WellKnownFederation {
    /// Base URL for the federation API (e.g., "https://accord.example.com/_federation")
    pub federation_endpoint: String,
    /// Server's public key (base64-encoded Ed25519)
    pub public_key: String,
    /// Protocol version
    pub protocol_version: u32,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_federated_user_id_parse() {
        let uid = FederatedUserId::parse("alice@example.com").unwrap();
        assert_eq!(uid.username, "alice");
        assert_eq!(uid.server_domain, "example.com");
        assert_eq!(uid.to_string_repr(), "alice@example.com");

        assert!(FederatedUserId::parse("alice").is_none());
        assert!(FederatedUserId::parse("@example.com").is_none());
        assert!(FederatedUserId::parse("alice@").is_none());
    }

    #[test]
    fn test_federated_user_id_is_local() {
        let uid = FederatedUserId::new("alice", "example.com");
        assert!(uid.is_local("example.com"));
        assert!(!uid.is_local("other.com"));
    }

    #[test]
    fn test_federation_event_serialization() {
        let event = FederationEvent::Message {
            message_id: Uuid::new_v4(),
            from: FederatedUserId::new("alice", "server-a.com"),
            to: FederatedUserId::new("bob", "server-b.com"),
            encrypted_payload: "encrypted_data_here".to_string(),
            reply_to: None,
        };

        let json = serde_json::to_string(&event).unwrap();
        let deserialized: FederationEvent = serde_json::from_str(&json).unwrap();

        match deserialized {
            FederationEvent::Message { from, to, .. } => {
                assert_eq!(from.username, "alice");
                assert_eq!(to.username, "bob");
            }
            _ => panic!("Wrong event type"),
        }
    }

    #[test]
    fn test_server_info_serialization() {
        let info = ServerInfo {
            domain: "example.com".to_string(),
            public_key: "base64key".to_string(),
            protocol_version: 1,
            software_version: "0.1.0".to_string(),
            capabilities: vec![
                capabilities::MESSAGING.to_string(),
                capabilities::PRESENCE.to_string(),
            ],
        };

        let json = serde_json::to_string(&info).unwrap();
        let deserialized: ServerInfo = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.domain, "example.com");
        assert_eq!(deserialized.capabilities.len(), 2);
    }

    #[test]
    fn test_federated_message_serialization() {
        let msg = FederatedMessage {
            sender_domain: "a.com".to_string(),
            recipient_domain: "b.com".to_string(),
            timestamp: 1234567890,
            nonce: "random_nonce".to_string(),
            event: FederationEvent::PresenceUpdate {
                user: FederatedUserId::new("alice", "a.com"),
                status: "online".to_string(),
                custom_status: Some("Working".to_string()),
            },
            signature: "sig_here".to_string(),
        };

        let json = serde_json::to_string(&msg).unwrap();
        let deserialized: FederatedMessage = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.sender_domain, "a.com");
        assert_eq!(deserialized.timestamp, 1234567890);
    }

    #[test]
    fn test_well_known_serialization() {
        let wk = WellKnownFederation {
            federation_endpoint: "https://example.com/_federation".to_string(),
            public_key: "base64key".to_string(),
            protocol_version: 1,
        };

        let json = serde_json::to_string(&wk).unwrap();
        assert!(json.contains("federation_endpoint"));
    }

    #[test]
    fn test_all_event_variants_serialize() {
        let events = vec![
            FederationEvent::Message {
                message_id: Uuid::new_v4(),
                from: FederatedUserId::new("a", "x.com"),
                to: FederatedUserId::new("b", "y.com"),
                encrypted_payload: "data".to_string(),
                reply_to: Some(Uuid::new_v4()),
            },
            FederationEvent::TypingStart {
                from: FederatedUserId::new("a", "x.com"),
                to: FederatedUserId::new("b", "y.com"),
                channel_id: Some(Uuid::new_v4()),
            },
            FederationEvent::PresenceUpdate {
                user: FederatedUserId::new("a", "x.com"),
                status: "online".to_string(),
                custom_status: None,
            },
            FederationEvent::JoinRequest {
                user: FederatedUserId::new("a", "x.com"),
                node_id: Uuid::new_v4(),
                invite_code: Some("abc123".to_string()),
            },
            FederationEvent::JoinResponse {
                user: FederatedUserId::new("a", "x.com"),
                node_id: Uuid::new_v4(),
                accepted: true,
                reason: None,
            },
            FederationEvent::Leave {
                user: FederatedUserId::new("a", "x.com"),
                node_id: Uuid::new_v4(),
            },
            FederationEvent::ServerHello {
                info: ServerInfo {
                    domain: "x.com".to_string(),
                    public_key: "key".to_string(),
                    protocol_version: 1,
                    software_version: "0.1.0".to_string(),
                    capabilities: vec![],
                },
            },
        ];

        for event in events {
            let json = serde_json::to_string(&event).unwrap();
            let _: FederationEvent = serde_json::from_str(&json).unwrap();
        }
    }
}
