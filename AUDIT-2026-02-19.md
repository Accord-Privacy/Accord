# Accord Codebase Audit ‚Äî 2026-02-19

## Summary

Full audit of the Accord codebase covering security, correctness, architecture, and known bugs.
**No fixes applied** ‚Äî this is observation only.

---

## üî¥ CRITICAL ‚Äî Security

### 1. Auth tokens passed in query strings (URL)
**Files:** `api.ts` (all endpoints), `handlers.rs` (`extract_user_from_token`)

Every API call passes the auth token as `?token=` in the URL query string. This means:
- Tokens appear in server access logs
- Tokens appear in browser history
- Tokens leak via HTTP Referer headers
- Tokens are visible in any proxy/load balancer logs
- If HTTPS is ever used, tokens still leak to intermediate infrastructure via URL

**Should be:** `Authorization: Bearer <token>` header. The code already has `extract_token_from_headers_or_params` (line 2278) which supports headers, but the frontend never uses it.

### 2. Auth tokens stored only in memory (partial)
**File:** `state.rs` line 1519

`register_bot()` is a stub that doesn't persist. But more importantly, `auth_tokens` HashMap is the primary auth store. Tokens ARE persisted to DB on creation (line ~380 state.rs `save_auth_token`), but on startup, the in-memory HashMap is empty ‚Äî meaning all users are logged out on every server restart. This is probably intentional but should be documented.

### 3. Channel encryption is a placeholder ‚Äî NOT E2EE
**File:** `crypto.ts` line 429

`createChannelKeyFromId()` derives a symmetric key from `channelId + 'accord-channel-key-v1'` using SHA-256. **Every user in the channel derives the exact same key.** The server knows the channelId and could trivially derive the same key. This provides zero confidentiality against the server.

This is documented in comments but not surfaced to users. The UI shows an "encrypted" indicator (üîí) which is misleading.

### 4. Auto-mod runs on encrypted data
**File:** `handlers.rs` line ~3778

```rust
state.db.check_auto_mod(channel.node_id, &encrypted_data)
```

The auto-mod word filter checks the **base64-encoded encrypted payload**. With the current placeholder encryption, the server *could* derive the key and decrypt first, but it doesn't. So auto-mod will:
- Never match real encrypted content (it's checking base64 gibberish)
- False-match if a banned word appears in the base64 encoding (unlikely but theoretically possible)
- If/when real E2EE is implemented, auto-mod becomes entirely non-functional server-side

### 5. Empty password allows login bypass
**File:** `state.rs` line ~320

```rust
if !stored_hash.is_empty() {
    // verify password
}
// If no password hash is stored, skip verification (legacy/keyless users)
```

If a user registered with an empty password, anyone with their public key hash can authenticate. This is documented as "legacy" but is still active.

### 6. No CSRF protection
The API uses query-param tokens and no CSRF tokens. Since the server runs on HTTP (not HTTPS) with CORS presumably open, a malicious page could make authenticated requests if the user has a token in their browser.

### 7. No TLS by default
Server runs on plain HTTP (`http://192.168.1.31:8443`). All auth tokens, messages (including the placeholder-encrypted ones), and user data travel in plaintext on the network.

---

## üü† HIGH ‚Äî Bugs (Known)

### 8. Cross-client decryption failure
**Status:** In progress, not yet resolved.

Browser (HTTP, noble fallback) and Tauri desktop (`crypto.subtle`) previously used different key derivation paths. Fixed by forcing noble for channel keys, but the current code has a subtle issue:

In `encryptMessage()` / `decryptMessage()` (crypto.ts ~475):
```typescript
const keyBytes = key instanceof Uint8Array ? key : new Uint8Array(0);
```

If `key` is somehow a CryptoKey instead of Uint8Array (e.g., from a stale cache entry before the fix), it silently uses an **empty key** (all zeros) for encryption. This would produce ciphertext that's impossible to decrypt with the correct key, with no error thrown.

### 9. Double chat messages appearing
**Status:** Known, not yet investigated.

Likely cause: `send_to_channel()` broadcasts to ALL members including the sender. The sender also adds a temp message locally. The dedup logic replaces the *oldest* matching temp message, but if the WebSocket event arrives before the temp is added (race condition), or if the temp match fails (different sender_id format), the message appears twice.

### 10. DirectMessage routing uses message_id as channel_id
**File:** `handlers.rs` line 3694

```rust
"channel_id": message_id, // Use message_id as temporary channel_id
```

Every DM creates a new fake channel_id from the message_id. This means:
- DM messages can never be grouped into a conversation thread on the receiving end
- The frontend DM channel system and this direct relay are two different systems that don't align
- Messages sent via `DirectMessage` WS type won't appear in the DM channel history

---

## üü° MEDIUM ‚Äî Bugs / Issues

### 11. `setupWebSocketHandlers` stale closure
**File:** `App.tsx` line ~643

The `useCallback` for `setupWebSocketHandlers` depends on `[encryptionEnabled, keyPair]`. But it also references `members`, `dmChannels`, `nodes`, `channels`, `selectedChannelId`, `selectedDmChannel`, etc. ‚Äî all of which are NOT in the dependency array.

This means WebSocket event handlers capture stale values of these state variables. For example:
- `members.find(m => m.user_id === data.from)` uses the members list from when the socket was created, not current
- `dmChannels.some(dm => dm.id === data.channel_id)` uses stale DM list
- Channel message filtering uses stale `selectedChannelId`

This is a classic React hooks stale closure bug and likely contributes to the double-message and missing-message issues.

### 12. Token refresh race condition
**File:** `App.tsx` line ~586

The token refresher re-authenticates with stored public key + password. But if multiple API calls fail with 401 simultaneously, the refresher could be called multiple times, creating multiple auth tokens. The `api.ts` refresher should have a mutex/dedup mechanism.

### 13. Message search can't work with E2EE
**File:** `handlers.rs` line ~2160, `models.rs` line ~870

Server-side search queries message metadata but can't search content because it's encrypted. The search endpoint exists and returns results, but the `note` field says "content is end-to-end encrypted and must be searched client-side." However, the client `SearchOverlay` component presumably displays these results ‚Äî which won't have decrypted content.

### 14. `loadAllMemberRoles` makes N+1 API calls
**File:** `App.tsx` line ~1174

For every member in a node, it makes a separate `getMemberRoles()` API call. In a node with 100 members, that's 100 HTTP requests. Should be a single batch endpoint.

### 15. Bot API is non-functional stubs
**File:** `state.rs` lines 1519-1540, `bot_api.rs`

All bot operations are in-memory stubs that return errors. `register_bot` succeeds but the bot is lost on restart. `get_bot`, `update_bot`, `delete_bot` always fail with "Bot not found."

### 16. `getKeyPassphrase` uses unstable token
**File:** `crypto.ts` line ~213

```typescript
const pkHash = localStorage.getItem('accord_public_key_hash') || '';
const token = localStorage.getItem('accord_token') || '';
return `accord-key-wrap:${pkHash || token}`;
```

Falls back to `token` if `pkHash` isn't set. But tokens change on every login. If the key was saved when `pkHash` wasn't set (using token as passphrase), and then the user logs in again (new token), the old encrypted key can never be decrypted. This creates the "Key Locked" state.

---

## üîµ LOW ‚Äî Code Quality / Architecture

### 17. App.tsx is 5,215 lines ‚Äî unmaintainable
A single React component file with all state, all handlers, all event processing, and all rendering. This is the #1 risk for introducing bugs ‚Äî every change can have unexpected interactions with hundreds of closures.

### 18. No input sanitization on channel message relay
**File:** `handlers.rs` line ~3860

The server relays `encrypted_data` directly without any validation beyond base64 decoding. While this is correct for encrypted data, the `sender_display_name` is also relayed from the user profile and could contain XSS payloads if rendered without sanitization in the frontend.

### 19. `validate_username` exists but is never called for registration
**File:** `validation.rs`

Registration (`register_handler`) doesn't validate any input format ‚Äî it only checks that `public_key` is non-empty. The `validate_username` function exists in validation.rs but registration doesn't use usernames. Display names set via `update_user_profile` aren't validated by `validate_display_name` in the handler (only bio length is checked).

### 20. Rate limiter doesn't clean up old entries
**File:** `rate_limit.rs`

The sliding window rate limiter stores timestamps in VecDeque but only prunes them during `check()` calls. If a user makes one request and never comes back, their entry persists in memory forever. For a long-running server with many unique IPs (registration brute-force attempts), this is a memory leak.

### 21. WebSocket broadcast channel buffer = 100
**File:** `handlers.rs` line ~3488

```rust
let (tx, mut rx) = broadcast::channel::<String>(100);
```

If a user is slow to consume and >100 messages arrive, older messages are dropped with `RecvError::Lagged`. The outgoing task doesn't handle this ‚Äî it just breaks on error. This means a user in a busy channel could silently miss messages with no reconnect.

### 22. No message ordering guarantees
Messages are ordered by `created_at` timestamp (server clock). If two messages arrive in the same second, their order is non-deterministic. The `id` is a UUID v4 (random), so it can't be used for ordering either. A monotonic sequence number per channel would be more reliable.

### 23. File encryption uses subtle/noble inconsistently
**File:** `crypto.ts` lines ~487-528

`encryptFile`/`decryptFile` check `HAS_SUBTLE && key instanceof CryptoKey` and use the Web Crypto path if both are true. But channel keys are now always noble (Uint8Array), so the subtle path is dead code for channel files. However, it could activate if a CryptoKey ended up in the cache somehow, creating the same cross-client incompatibility that was just "fixed" for messages.

### 24. DER encoding assumes small sizes
**File:** `crypto.ts` lines ~240-300

The SPKI/PKCS8 DER encoding uses single-byte length fields (short form). This works for P-256 keys but would silently produce invalid DER for larger keys. Not a current issue but fragile.

### 25. `cargo audit` not installed
`cargo audit` is not available on this machine, meaning the pre-push QA script's audit step either fails or is skipped.

---

## üìã Known Bugs Summary (from testing)

| # | Bug | Status | Root Cause |
|---|-----|--------|------------|
| 1 | Cross-client decryption | In progress | noble vs subtle paths; zero-key fallback |
| 2 | Double chat messages | Not investigated | Server echo + stale closure + dedup race |
| 3 | "Key Locked" badge | Intermittent | `getKeyPassphrase` token fallback |
| 4 | Recovery flow issues | Fixed (fa07458, bdb15a5) | `needsRelayUrl` guard, missing UI |
| 5 | Message dedup dropping own msgs | Fixed (4809f15) | Missing exact-match check |
| 6 | "0" content / Invalid Date | Fixed (4809f15) | `created_at` seconds not converted to ms |
| 7 | Create node modal doesn't close | Fixed (4306e7f) | Async call before state update |

---

## üèóÔ∏è Architecture Observations

1. **Monolithic frontend** ‚Äî 5.2K-line App.tsx needs component extraction badly. State management should move to a proper store (Zustand, Jotai, or at minimum React Context).

2. **Two DM systems** ‚Äî The `DirectMessage` WS type is a fire-and-forget relay. The DM channel system stores messages persistently. They don't share state, and the WS handler for incoming DMs uses the wrong channel_id (message_id instead of DM channel id).

3. **Server stores encrypted blobs as raw bytes, returns as base64** ‚Äî The flow is: client base64-encodes ‚Üí server base64-decodes to bytes ‚Üí stores bytes ‚Üí base64-encodes for API response. This is correct and consistent. No double-encoding issue found in the message history path.

4. **Permission system is clean** ‚Äî Well-structured with proper role hierarchy. The frontend mirrors it but with a simpler 3-role model that doesn't fully leverage the server's custom role system.

5. **No WebSocket authentication rotation** ‚Äî If a token expires while a WebSocket is open, the connection stays alive. The token is only validated at connection time.

---

## Recommendations (Priority Order)

1. **Move auth tokens to headers** ‚Äî Critical security fix
2. **Fix stale closure in setupWebSocketHandlers** ‚Äî Root cause of multiple UI bugs
3. **Fix zero-key fallback in encrypt/decrypt** ‚Äî Throw instead of silently using empty key
4. **Unify DM systems** ‚Äî Remove `DirectMessage` WS type, use only DM channels
5. **Split App.tsx** ‚Äî Extract state management, WebSocket handler, message components
6. **Surface encryption reality to users** ‚Äî Don't show üîí for placeholder encryption, or clearly label it "transport encryption" vs "E2EE"
7. **Implement proper channel E2EE** ‚Äî Sender Keys or MLS to replace placeholder
8. **Add TLS support** ‚Äî Even self-signed for LAN use
9. **Install cargo-audit** and add to CI
10. **Batch member role API** ‚Äî Single endpoint instead of N+1
